#' Argument matching with defaults
#'
#' \code{match_call_defaults} operates similar to \code{\link{match.call}}, but
#' considers also unset arguments for which defaults exist.
#'
#' @param call an unevaluated call to a function, as generated by
#'  \code{\link{call}}
#' @param .formals the formal argument definition of \code{call}
#' @return \code{match_call_defaults} returns a \code{call} corresponding to
#' the \code{call} argument, whose missing values have been filled in by the
#' defaults provided by \code{.formals}; the arguments are unevaluated.
#' @details
#' Both \code{call} and \code{.formals} have defaults which refer to the
#' function from which \code{match_call_defaults} was invoked. Thus, in normal
#' usage no arguments are specified.
#'
#' The function is useful to forward a call to a different function, when most
#' arguments remain unchanged. See examples.
#'
#' @examples
#' paste_csv = function (..., sep = ',', collapse = NULL) {
#'     call = base$match_call_defaults()
#'     call[[1]] = quote(paste)
#'     eval.parent(call)
#' }
#'
#' paste_csv('a', 'test') # => "a,test"
#' paste_csv('a', 'test', sep = ';') # => "a;test"
match_call_defaults = function (call = match.call(sys.function(sys.parent()),
                                                  sys.call(sys.parent())),
                                .formals = formals(sys.function(sys.parent()))) {
    .formals = .formals[names(.formals) != '...']
    missing = is.na(match(names(.formals), names(call)))
    missing_names = names(.formals)[missing]
    missing_values = .formals[missing]
    call[missing_names] = missing_values
    call
}

messageU <- function(..., underline='=', overline='=') {
    x <- paste0(..., collapse='')
    if (!is.null(overline)) {
        message(rep(overline, nchar(x)))
    }
    message(x)
    if (!is.null(underline)) {
        message(rep(underline, nchar(x)))
    }
}

startTimedMessage <- function(...) {
    x <- paste0(..., collapse='')
    message(x, appendLF=FALSE)
    ptm <- proc.time()
    return(ptm)
}

stopTimedMessage <- function(ptm) {
    time <- proc.time() - ptm
    message(" ", round(time[3],2), "s")
}

args2fname <- function(base, ..., ext='.rds') {
    fmt <- function(key, value) {
        if (is.character(value)) {
            if (nchar(key) > 0)
                paste(key, value, sep="-")
            else
                value
        } else
            gsub("\\+0", "", sprintf("%s%.2g", key, value))
    }
    args <- list(...)
    if (length(args) > 0) {
        fmtd <- paste(mapply(fmt, names(args), args), collapse="_")
        sprintf("%s_%s%s", base, fmtd, ext)
    } else
        sprintf("%s%s", base, ext)
}

makedir <- function(...) {
    path <- file.path(...)
    if (!file.exists(path))
        dir.create(path)
    invisible(path)
}

transCoord <- function(gr) {
    cum.seqlengths        <- cumsum(as.numeric(seqlengths(gr)))
    cum.seqlengths.0      <- c(0,cum.seqlengths[-length(cum.seqlengths)])
    names(cum.seqlengths.0) <- seqlevels(gr)
    gr$start.genome       <- start(gr) + cum.seqlengths.0[as.character(seqnames(gr))]
    gr$end.genome         <- end(gr) + cum.seqlengths.0[as.character(seqnames(gr))]
    gr
}

stateColors <- function(states=c('zero-inflation', paste0(0:10, '-somy'), 'total')) {
    state.colors <- c("zero-inflation"="gray90", "0-somy"="gray90","1-somy"="darkorchid3",
                      "2-somy"="springgreen2","3-somy"="red3","4-somy"="gold2",
                      "5-somy"="navy","6-somy"="lemonchiffon","7-somy"="dodgerblue",
                      "8-somy"="chartreuse4","9-somy"="lightcoral","10-somy"="aquamarine2",
                      "total"="black")
    states.with.color <- intersect(states, names(state.colors))
    cols              <- rep('black', length(states))
    names(cols)       <- states
    cols[states.with.color] <- state.colors[states.with.color]
    cols
}
